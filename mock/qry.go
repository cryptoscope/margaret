// Code generated by counterfeiter. DO NOT EDIT.
package mock

import (
	"sync"

	"go.cryptoscope.co/margaret"
)

type FakeQuery struct {
	GtStub        func(margaret.Seq) error
	gtMutex       sync.RWMutex
	gtArgsForCall []struct {
		arg1 margaret.Seq
	}
	gtReturns struct {
		result1 error
	}
	gtReturnsOnCall map[int]struct {
		result1 error
	}
	GteStub        func(margaret.Seq) error
	gteMutex       sync.RWMutex
	gteArgsForCall []struct {
		arg1 margaret.Seq
	}
	gteReturns struct {
		result1 error
	}
	gteReturnsOnCall map[int]struct {
		result1 error
	}
	LimitStub        func(int) error
	limitMutex       sync.RWMutex
	limitArgsForCall []struct {
		arg1 int
	}
	limitReturns struct {
		result1 error
	}
	limitReturnsOnCall map[int]struct {
		result1 error
	}
	LiveStub        func(bool) error
	liveMutex       sync.RWMutex
	liveArgsForCall []struct {
		arg1 bool
	}
	liveReturns struct {
		result1 error
	}
	liveReturnsOnCall map[int]struct {
		result1 error
	}
	LtStub        func(margaret.Seq) error
	ltMutex       sync.RWMutex
	ltArgsForCall []struct {
		arg1 margaret.Seq
	}
	ltReturns struct {
		result1 error
	}
	ltReturnsOnCall map[int]struct {
		result1 error
	}
	LteStub        func(margaret.Seq) error
	lteMutex       sync.RWMutex
	lteArgsForCall []struct {
		arg1 margaret.Seq
	}
	lteReturns struct {
		result1 error
	}
	lteReturnsOnCall map[int]struct {
		result1 error
	}
	SeqWrapStub        func(bool) error
	seqWrapMutex       sync.RWMutex
	seqWrapArgsForCall []struct {
		arg1 bool
	}
	seqWrapReturns struct {
		result1 error
	}
	seqWrapReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeQuery) Gt(arg1 margaret.Seq) error {
	fake.gtMutex.Lock()
	ret, specificReturn := fake.gtReturnsOnCall[len(fake.gtArgsForCall)]
	fake.gtArgsForCall = append(fake.gtArgsForCall, struct {
		arg1 margaret.Seq
	}{arg1})
	fake.recordInvocation("Gt", []interface{}{arg1})
	fake.gtMutex.Unlock()
	if fake.GtStub != nil {
		return fake.GtStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.gtReturns
	return fakeReturns.result1
}

func (fake *FakeQuery) GtCallCount() int {
	fake.gtMutex.RLock()
	defer fake.gtMutex.RUnlock()
	return len(fake.gtArgsForCall)
}

func (fake *FakeQuery) GtCalls(stub func(margaret.Seq) error) {
	fake.gtMutex.Lock()
	defer fake.gtMutex.Unlock()
	fake.GtStub = stub
}

func (fake *FakeQuery) GtArgsForCall(i int) margaret.Seq {
	fake.gtMutex.RLock()
	defer fake.gtMutex.RUnlock()
	argsForCall := fake.gtArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeQuery) GtReturns(result1 error) {
	fake.gtMutex.Lock()
	defer fake.gtMutex.Unlock()
	fake.GtStub = nil
	fake.gtReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeQuery) GtReturnsOnCall(i int, result1 error) {
	fake.gtMutex.Lock()
	defer fake.gtMutex.Unlock()
	fake.GtStub = nil
	if fake.gtReturnsOnCall == nil {
		fake.gtReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.gtReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeQuery) Gte(arg1 margaret.Seq) error {
	fake.gteMutex.Lock()
	ret, specificReturn := fake.gteReturnsOnCall[len(fake.gteArgsForCall)]
	fake.gteArgsForCall = append(fake.gteArgsForCall, struct {
		arg1 margaret.Seq
	}{arg1})
	fake.recordInvocation("Gte", []interface{}{arg1})
	fake.gteMutex.Unlock()
	if fake.GteStub != nil {
		return fake.GteStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.gteReturns
	return fakeReturns.result1
}

func (fake *FakeQuery) GteCallCount() int {
	fake.gteMutex.RLock()
	defer fake.gteMutex.RUnlock()
	return len(fake.gteArgsForCall)
}

func (fake *FakeQuery) GteCalls(stub func(margaret.Seq) error) {
	fake.gteMutex.Lock()
	defer fake.gteMutex.Unlock()
	fake.GteStub = stub
}

func (fake *FakeQuery) GteArgsForCall(i int) margaret.Seq {
	fake.gteMutex.RLock()
	defer fake.gteMutex.RUnlock()
	argsForCall := fake.gteArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeQuery) GteReturns(result1 error) {
	fake.gteMutex.Lock()
	defer fake.gteMutex.Unlock()
	fake.GteStub = nil
	fake.gteReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeQuery) GteReturnsOnCall(i int, result1 error) {
	fake.gteMutex.Lock()
	defer fake.gteMutex.Unlock()
	fake.GteStub = nil
	if fake.gteReturnsOnCall == nil {
		fake.gteReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.gteReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeQuery) Limit(arg1 int) error {
	fake.limitMutex.Lock()
	ret, specificReturn := fake.limitReturnsOnCall[len(fake.limitArgsForCall)]
	fake.limitArgsForCall = append(fake.limitArgsForCall, struct {
		arg1 int
	}{arg1})
	fake.recordInvocation("Limit", []interface{}{arg1})
	fake.limitMutex.Unlock()
	if fake.LimitStub != nil {
		return fake.LimitStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.limitReturns
	return fakeReturns.result1
}

func (fake *FakeQuery) LimitCallCount() int {
	fake.limitMutex.RLock()
	defer fake.limitMutex.RUnlock()
	return len(fake.limitArgsForCall)
}

func (fake *FakeQuery) LimitCalls(stub func(int) error) {
	fake.limitMutex.Lock()
	defer fake.limitMutex.Unlock()
	fake.LimitStub = stub
}

func (fake *FakeQuery) LimitArgsForCall(i int) int {
	fake.limitMutex.RLock()
	defer fake.limitMutex.RUnlock()
	argsForCall := fake.limitArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeQuery) LimitReturns(result1 error) {
	fake.limitMutex.Lock()
	defer fake.limitMutex.Unlock()
	fake.LimitStub = nil
	fake.limitReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeQuery) LimitReturnsOnCall(i int, result1 error) {
	fake.limitMutex.Lock()
	defer fake.limitMutex.Unlock()
	fake.LimitStub = nil
	if fake.limitReturnsOnCall == nil {
		fake.limitReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.limitReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeQuery) Live(arg1 bool) error {
	fake.liveMutex.Lock()
	ret, specificReturn := fake.liveReturnsOnCall[len(fake.liveArgsForCall)]
	fake.liveArgsForCall = append(fake.liveArgsForCall, struct {
		arg1 bool
	}{arg1})
	fake.recordInvocation("Live", []interface{}{arg1})
	fake.liveMutex.Unlock()
	if fake.LiveStub != nil {
		return fake.LiveStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.liveReturns
	return fakeReturns.result1
}

func (fake *FakeQuery) LiveCallCount() int {
	fake.liveMutex.RLock()
	defer fake.liveMutex.RUnlock()
	return len(fake.liveArgsForCall)
}

func (fake *FakeQuery) LiveCalls(stub func(bool) error) {
	fake.liveMutex.Lock()
	defer fake.liveMutex.Unlock()
	fake.LiveStub = stub
}

func (fake *FakeQuery) LiveArgsForCall(i int) bool {
	fake.liveMutex.RLock()
	defer fake.liveMutex.RUnlock()
	argsForCall := fake.liveArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeQuery) LiveReturns(result1 error) {
	fake.liveMutex.Lock()
	defer fake.liveMutex.Unlock()
	fake.LiveStub = nil
	fake.liveReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeQuery) LiveReturnsOnCall(i int, result1 error) {
	fake.liveMutex.Lock()
	defer fake.liveMutex.Unlock()
	fake.LiveStub = nil
	if fake.liveReturnsOnCall == nil {
		fake.liveReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.liveReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeQuery) Lt(arg1 margaret.Seq) error {
	fake.ltMutex.Lock()
	ret, specificReturn := fake.ltReturnsOnCall[len(fake.ltArgsForCall)]
	fake.ltArgsForCall = append(fake.ltArgsForCall, struct {
		arg1 margaret.Seq
	}{arg1})
	fake.recordInvocation("Lt", []interface{}{arg1})
	fake.ltMutex.Unlock()
	if fake.LtStub != nil {
		return fake.LtStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.ltReturns
	return fakeReturns.result1
}

func (fake *FakeQuery) LtCallCount() int {
	fake.ltMutex.RLock()
	defer fake.ltMutex.RUnlock()
	return len(fake.ltArgsForCall)
}

func (fake *FakeQuery) LtCalls(stub func(margaret.Seq) error) {
	fake.ltMutex.Lock()
	defer fake.ltMutex.Unlock()
	fake.LtStub = stub
}

func (fake *FakeQuery) LtArgsForCall(i int) margaret.Seq {
	fake.ltMutex.RLock()
	defer fake.ltMutex.RUnlock()
	argsForCall := fake.ltArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeQuery) LtReturns(result1 error) {
	fake.ltMutex.Lock()
	defer fake.ltMutex.Unlock()
	fake.LtStub = nil
	fake.ltReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeQuery) LtReturnsOnCall(i int, result1 error) {
	fake.ltMutex.Lock()
	defer fake.ltMutex.Unlock()
	fake.LtStub = nil
	if fake.ltReturnsOnCall == nil {
		fake.ltReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.ltReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeQuery) Lte(arg1 margaret.Seq) error {
	fake.lteMutex.Lock()
	ret, specificReturn := fake.lteReturnsOnCall[len(fake.lteArgsForCall)]
	fake.lteArgsForCall = append(fake.lteArgsForCall, struct {
		arg1 margaret.Seq
	}{arg1})
	fake.recordInvocation("Lte", []interface{}{arg1})
	fake.lteMutex.Unlock()
	if fake.LteStub != nil {
		return fake.LteStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.lteReturns
	return fakeReturns.result1
}

func (fake *FakeQuery) LteCallCount() int {
	fake.lteMutex.RLock()
	defer fake.lteMutex.RUnlock()
	return len(fake.lteArgsForCall)
}

func (fake *FakeQuery) LteCalls(stub func(margaret.Seq) error) {
	fake.lteMutex.Lock()
	defer fake.lteMutex.Unlock()
	fake.LteStub = stub
}

func (fake *FakeQuery) LteArgsForCall(i int) margaret.Seq {
	fake.lteMutex.RLock()
	defer fake.lteMutex.RUnlock()
	argsForCall := fake.lteArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeQuery) LteReturns(result1 error) {
	fake.lteMutex.Lock()
	defer fake.lteMutex.Unlock()
	fake.LteStub = nil
	fake.lteReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeQuery) LteReturnsOnCall(i int, result1 error) {
	fake.lteMutex.Lock()
	defer fake.lteMutex.Unlock()
	fake.LteStub = nil
	if fake.lteReturnsOnCall == nil {
		fake.lteReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.lteReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeQuery) SeqWrap(arg1 bool) error {
	fake.seqWrapMutex.Lock()
	ret, specificReturn := fake.seqWrapReturnsOnCall[len(fake.seqWrapArgsForCall)]
	fake.seqWrapArgsForCall = append(fake.seqWrapArgsForCall, struct {
		arg1 bool
	}{arg1})
	fake.recordInvocation("SeqWrap", []interface{}{arg1})
	fake.seqWrapMutex.Unlock()
	if fake.SeqWrapStub != nil {
		return fake.SeqWrapStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.seqWrapReturns
	return fakeReturns.result1
}

func (fake *FakeQuery) SeqWrapCallCount() int {
	fake.seqWrapMutex.RLock()
	defer fake.seqWrapMutex.RUnlock()
	return len(fake.seqWrapArgsForCall)
}

func (fake *FakeQuery) SeqWrapCalls(stub func(bool) error) {
	fake.seqWrapMutex.Lock()
	defer fake.seqWrapMutex.Unlock()
	fake.SeqWrapStub = stub
}

func (fake *FakeQuery) SeqWrapArgsForCall(i int) bool {
	fake.seqWrapMutex.RLock()
	defer fake.seqWrapMutex.RUnlock()
	argsForCall := fake.seqWrapArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeQuery) SeqWrapReturns(result1 error) {
	fake.seqWrapMutex.Lock()
	defer fake.seqWrapMutex.Unlock()
	fake.SeqWrapStub = nil
	fake.seqWrapReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeQuery) SeqWrapReturnsOnCall(i int, result1 error) {
	fake.seqWrapMutex.Lock()
	defer fake.seqWrapMutex.Unlock()
	fake.SeqWrapStub = nil
	if fake.seqWrapReturnsOnCall == nil {
		fake.seqWrapReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.seqWrapReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeQuery) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.gtMutex.RLock()
	defer fake.gtMutex.RUnlock()
	fake.gteMutex.RLock()
	defer fake.gteMutex.RUnlock()
	fake.limitMutex.RLock()
	defer fake.limitMutex.RUnlock()
	fake.liveMutex.RLock()
	defer fake.liveMutex.RUnlock()
	fake.ltMutex.RLock()
	defer fake.ltMutex.RUnlock()
	fake.lteMutex.RLock()
	defer fake.lteMutex.RUnlock()
	fake.seqWrapMutex.RLock()
	defer fake.seqWrapMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeQuery) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ margaret.Query = new(FakeQuery)
